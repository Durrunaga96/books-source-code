//*******************************************************************//// BinarySearchTree.java			Authors: Lewis/Chase//// Implements the BinarySearchTreeADT interface with links//*******************************************************************package jss2;import jss2.exceptions.*;import jss2.*;public class BinarySearchTree extends BinaryTree implements BinarySearchTreeADT {   //================================================================   //  Creates an empty binary search tree.   //================================================================   public BinarySearchTree()    {      super();   }  // constructor BinarySearchTree   //================================================================   //  Creates a binary search with the specified element as its   //  root.   //================================================================   public BinarySearchTree (Comparable element)    {      super (element);   }  // constructor BinarySearchTree   //================================================================   //  Adds the specified object to the binary search tree in the   //  appropriate position according to its key value.  Note that   //  equal elements are added to the right.   //================================================================   public void addElement (Comparable element)    {      BinaryTreeNode temp = new BinaryTreeNode (element);      if (isEmpty())         root = temp;      else       {         BinaryTreeNode current = root;         boolean added = false;         while (!added)          {            if (element.compareTo(current.element) < 0)               if (current.left == null)                {                  current.left = temp;                  added = true;               }                else                  current = current.left;            else               if (current.right == null)                {                  current.right = temp;                  added = true;               }                else                  current = current.right;         }//while      }//else      count++;   }  // method addElement   //================================================================   //  Removes the first element that matches the specified target   //  element from the binary search tree and returns a reference to   //  it.  Throws a ElementNotFoundException if the specified target   //  element is not found in the binary search tree.   //================================================================   public Comparable removeElement (Comparable targetElement) throws   ElementNotFoundException    {       Comparable result = null;      if (!isEmpty())         if (targetElement.equals(root.element))          {            result = (Comparable) root.element;            root = replacement (root);            count--;         } //if        else         {            BinaryTreeNode current, parent = root;            boolean found = false;            if (targetElement.compareTo(root.element) < 0)               current = root.left;            else               current = root.right;            while (current != null && !found)             {               if (targetElement.equals(current.element))                {                  found = true;                  count--;                  result = (Comparable) current.element;                            if (current == parent.left)                  {                     parent.left = replacement (current);                  }                  else                  {                     parent.right = replacement (current);                  }               } //if              else               {                  parent = current;                           if (targetElement.compareTo(current.element) < 0)                     current = current.left;                  else                     current = current.right;               } //else            } //while            if (!found)               throw new ElementNotFoundException("binary tree");         } //else      return result;   }  // method removeElement   //================================================================   //  Removes elements that match the specified target   //  element from the binary search tree    //  Throws a ElementNotFoundException if the sepcified target   //  element is not found in the binary search tree.   //================================================================   public void removeAllOccurrences (Comparable targetElement) throws   ElementNotFoundException    {      removeElement(targetElement);            try	 {	   while (contains(targetElement))          removeElement(targetElement);	 }	 catch (Exception ElementNotFoundException)	 {	 }            }  // method removeAllOccurrences   //================================================================   //  Removes the node with the least value from the binary search   //  tree and returns a reference to its element.  Throws an   //  EmptyBinarySearchTreeException if the binary search tree is   //  empty.    //================================================================   public Comparable removeMin() throws EmptyCollectionException    {   }  // method removeMin   //================================================================   //  Removes the node with the highest value from the binary   //  search tree and returns a reference to its element.  Throws an   //  EmptyBinarySearchTreeException if the binary search tree is   //  empty.    //================================================================   public Comparable removeMax() throws EmptyCollectionException    {   }  // method removeMax   //================================================================   //  Returns the element with the least value in the binary search   //  tree.  It does not remove the node from the binary search   //  tree.  Throws an EmptyBinarySearchTreeException if the binary   //  search tree is empty.   //================================================================   public Comparable findMin() throws EmptyCollectionException    {   }  // method findMin   //================================================================   //  Returns the element with the highest value in the binary   //  search tree.  It does not remove the node from the binary   //  search tree.  Throws an EmptyBinarySearchTreeException if the    //  binary search tree is empty.   //================================================================   public Comparable findMax() throws EmptyCollectionException    {   }  // method findMax   //================================================================   //  Returns a reference to the specified target element if it is   //  found in the binary tree.  Throws a NoSuchElementException if   //  the specified target element is not found in the binary tree.   //================================================================   public Object find (Comparable targetElement) throws ElementNotFoundException    {   }  // method find   //================================================================   //  Returns a reference to the specified target element if it is   //  found in the binary tree.     //================================================================   private BinaryTreeNode findagain (Comparable targetElement, BinaryTreeNode next)    {   }  // method findagain   //================================================================   //  Returns a reference to a node that will replace the one   //  specified for removal.  In the case where the removed   //  node has two children, the inorder successor is used   //  as its replacement.   //================================================================   protected BinaryTreeNode replacement (BinaryTreeNode node)    {      BinaryTreeNode result = null;      if ((node.left == null)&&(node.right==null))            result = null;      else if ((node.left != null)&&(node.right==null))            result = node.left;      else if ((node.left == null)&&(node.right != null))            result = node.right;      else      {            BinaryTreeNode current = node.right;            BinaryTreeNode parent = node;            while (current.left != null)             {               parent = current;               current = current.left;            }//while            if (node.right == current)               current.left = node.left;            else            {               parent.left = current.right;               current.right = node.right;               current.left = node.left;            }            result = current;      }//else      return result;   }  // method replacement}  // class BinarySearchTree